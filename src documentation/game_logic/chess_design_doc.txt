1. Overview
The chess game logic is designed as a server-side Java application, focusing on core game mechanics, piece movement, and turn management. The architecture is object-oriented, leveraging inheritance and polymorphism for different chess pieces. 

2. Class Diagram

ChessGame ────┬── Player ────┬── Piece ────┬── King
              │              │             ├── Queen
              │              │             ├── Bishop
              │              │             ├── Knight
              │              │             ├── Rook
              │              │             └── Pawn
              │              │
              │              └── Square
              │
              └── IPiece (Interface)

3. Class Responsibilities
3.1 ChessGame
Core Game Manager: Initializes the board, players, and tracks the active player.

Static Board Setup: Creates an 8x8 grid of Square objects mapped to names (e.g., a1, h8).

Player Management: Instantiates Player objects (white and black) and links them as opponents.

3.2 Player
Turn Handling: Processes clicks via enactClick(), selects pieces, and triggers moves.

Piece Management: Initializes all pieces (16 per player) in initializePieces().

Move Execution:

Captures pieces, updates positions, and calculates material advantage in move().

Maintains lists of captured pieces and move options.

3.3 Piece (Abstract)
Base Class: Implements IPiece and defines common properties (e.g., value, position, isWhite).

Subclasses (King, Queen, etc.):

Set initial positions (e.g., white King at e1, black Pawns at rank 7).

Override findMoveOptions() to calculate valid moves (pending implementation).

3.4 Square
Board Representation: Stores rank/file indices and name (e.g., a1).

Immutable: Coordinates and name are final.

3.5 IPiece (Interface)
Contract: Enforces implementation of findMoveOptions() for all piece types.

4. Key Features
Turn-Based Mechanics: Players alternate via activePlayer.

Piece Initialization: Correct starting positions for all pieces (except black Pawns; see Issues).

Click Handling: Selection and movement via enactClick() and move().

Material Tracking: materialAdvantage updates when pieces are captured.

5. Incomplete/Pending Parts
Movement Logic: findMoveOptions() is unimplemented in all subclasses (e.g., no logic for Knight’s L-shaped moves).

Special Rules: Castling, en passant, pawn promotion, and check/checkmate are missing.

Board State: No validation for checks or game-ending conditions.

Multiplayer Support: Static board and nameToSquare may conflict in multi-instance setups.

6. Potential Issues
Black Pawn Initialization:

Code: Pawn constructor places black pawns at board[7][file-1] (rank 8).

Fix: Should be board[6][file-1] (rank 7).

Static Board:

board and nameToSquare are static, risking cross-game interference.

Move Validation:

No checks for obstructions, enemy pieces, or legality beyond capturing.

Material Advantage Calculation:

Opponent’s materialAdvantage is decremented directly, but values should reflect total remaining pieces.

7. Dependencies
Intra-Package: Classes rely on shared Square, Player, and ChessGame references.

Assumptions:

Single-game instance (due to static board).

Client-server communication (hinted by comments in enactClick()).

8. Future Work
Implement findMoveOptions():

Add logic for each piece’s movement (e.g., diagonal for Bishop, L-shape for Knight).

Special Moves:

Add castling, en passant, and pawn promotion.