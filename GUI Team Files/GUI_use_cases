Use Case 1: Challenge Players

Iteration: 3, last modification: March 6th by Sage

Primary Actor: Registered Player

Goal in context: Allow a logged-in player to challenge another player to a match in an available online board game

Preconditions: 
1. The user is logged into their account
2. The user has an active internet connection
3. The opponent they wish to challenge must also be a registered user and online
4. The game server must be running
5. At least one game must be available for selection

Trigger: The player selects the option to challenge another player from the GUI

Scenario: 
1. The player navigates to the "Challenge Players" section in the GUI
2. The system displays a list of available online players
3. The player selects an opponent from the list by clicking on their username
4. The system highlights the selected player and displays a "Challenge" button
5. The player clicks the "Challenge" button
6. The system prompts the player to select a game from the available options
7. The player selects a game and clicks "Confirm Challenge."
8. The system sends a challenge request to the selected opponent
9. The opponent receives a pop-up notification with "Accept" and "Decline" buttons
10. The opponent either accepts or declines the challenge by clicking one of the buttons

Post conditions:
1. If the challenge is accepted, both players enter the game lobby, ready to start the match
2. If the challenge is declined, the challenger is returned to the "Challenge Players" screen

Exceptions:
1. The opponent goes offline before responding: the system notifies the player and sends them back to the "Challenge Players" screen
3. The game server is unavailable or down: the system notifies the player and prevents challenges from being sent
4. The opponent is already in another match: the system notifies the player and directs them back to the online players screen
5. The challenger cancels the request before the opponent responds: the system cancels sending the challenge notification to the opponent
6. User clicks outside of the challenge pop-up: the challenge request remains pending until the opponent responds or times out

Priority: High, this feature is essential for multiplayer games and direct player interaction and matchmaking

When available: This feature is always accessible to players in the GUI once they are logged in and connected to the game server

Frequency of use: Every time a player logs in to the server and wants to play a game with another user online

Channel to actor: The player interacts through the GUI by selecting from the options to challenge another player who is online

Secondary actors: 
1. Opponent Player (receives the challenge and chooses whether to accept)
2. Game Server (handles matchmaking and game initialization)

Channel to secondary actors:
1. Opponent Player: receives an in-game notification with an interactive "Accept/Decline" pop-up
2. Game Server: Processes and maintains server status, game availability and matchmaking status for players

Open issues:
1. Multiple incoming challenges to the same player
2. Ability to block another user to avoid receiving challenge requests from them
3. Timeout  mechanism for responding to challenges to prevent inactive or AFK players from slowing matchmaking times
4. Having a friends list of specific players you frequently play with


Use case 2: In-Game Chatting feature

Iteration: 1

Primary Actor: Player (active in game session)

Goal in context: Enable real-time texting between players during gameplay without interrupting the gaming experience, allowing for social interaction, game strategy, and sportsmanship.

Preconditions:

    - User is logged in to the system
    - User is currently participating in an active game session
    - At least one opponent or teammate is connected to the same game session
    - User has not been muted or restricted from the chatting feature

Trigger:

    - User activates chat interface by clicking chat icon or using keyboard shortcut
    - User receives message from another player
    - System event occurs requiring player notification (game state changes, turn alerts)

Scenario:

    - The player initiates the chat interface during an active game
    - System displays chat window in a non-intrusive position relative to the game board
    - System loads and displays the most recent message history (last 20 messages or configurable amount).
    - Player types the message in the text input box.
    - Player sends a message by pressing Enter key or clicking Send button
    - System validates messages for length and content restrictions.
    - System transmits message to messaging service with metadata (sender, timestamp, game session)
    - System displays the message in the local chat history with appropriate formatting
    - Recipients receive and view the message in their chat window
    - System sends a subtle notification sound (if enabled in user preferences)
    - Chat window can be minimized or relocated by user if desired
    - User can scroll through message history while game continues
    - If chat is inactive for 30 seconds, it automatically minimizes (optional tweek)

Post conditions:

    - Messages are left in the chat history throughout the game session
    - All active participants can view the message
    - Game state and performance remain unaffected
    - Chat history is saved with game record for potential review

Exceptions:

    - Message exceeds length limit - System displays character count warning and prevents submission
    - Inappropriate content detection - System filters content according to platform policy, or blocks message and warns user
    - Rapid message flooding - System implements cooldown and notifies user to prevent spam
    - Connectivity issue - System queues message for retry and displays sending status indicator
    - Recipient has blocked sender - Message is sent but not delivered, with no notification to sender
    - User has enabled "focus mode" - Incoming messages are queued but notifications suppressed
    - Game is in critical state (time pressure, final moves) - System may delay non-urgent notifications

Priority: Medium-High

When available: Iteration 2

Frequency of use: Very frequent - multiple times per game session

Channel to actor:

    - Visual chat interface within game UI
    - Notification system (visual and/or audio)
    - Optional keyboard shortcuts

Secondary actors:

    - Other players in the game (Opponents/Opponent)
    - The system that handles messages
    - Basic content filtering

Channel to secondary actors:

    - Basic communication between game components
    - Real-time connection for instant messaging
    - Connection to the main game session

Open issues:
    - Should private messaging between specific groups (e.g., team members) be allowed in team-based game modes?
    - How should chat history be saved between game sessions for regular opponents?
    - Should chat have rich text formatting or emoji reactions?
    - How to balance chat visibility with space constraints in small screens
    - Should voice chat be considered a future enhancement?
    - How to manage international player translations?
    - What level of administrative control is needed for chat moderation?
    - Should chat support auto-send game event notifications?
    - How will the "chat" feature scale between different game types (e.g., turn-based vs. real-time)?

Use Case 3: Look up Players 

Iteration: 1

Primary actor: Registered Player

Goal in context: To allow users to search for players using the GUI search feature, to access their profiles, and to examine stats before challenging them.

Preconditions:
1. The user is logged in.
2. The user has an internet connection.
3. The dashboard window is fully loaded, displaying a button called “Look up Player”

Trigger: The user selects the user “Look up Players” button with their mouse. 

Scenario:
1. The user enters a player's name into the search bar and the list updates dynamically with similar names.
2. The user applies filters (e.g., level, games played) via dropdown menus.
3. The user sorts the list by name, level, or other attributes using sorting buttons.
4. The user enters a player's name into the search bar.
5. The user scrolls through the list using their mouse or the scroll bar.

Postconditions:
1. The selected player’s profile is displayed in a new window.
2. Hovering over a name in the list triggers a pop-up showing the player's name and stats.

Exceptions:
1. If no matching players are found, the GUI displays a "No players found" message.
2. If the user loses connection while searching, the GUI displays a "Connection lost. Couldn’t load list." message.

Priority: High. A multiplayer GUI has to provide a way to access player stats of all players, for users to find and interact with others.

When available: Third iteration. 

Frequency of use: High. Players will frequently use this feature to find opponents.

Channel to actor: The GUI 

Secondary actors: 
1. The player database.  
2. The backend server. 

Channels to secondary actors: Internet 

Open issues: None

